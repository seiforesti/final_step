import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { Progress } from '@/components/ui/progress';
import { Switch } from '@/components/ui/switch';
import { Textarea } from '@/components/ui/textarea';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { 
  GitBranch,
  Shuffle,
  ArrowRight,
  ArrowDown,
  ArrowUp,
  Plus,
  Minus,
  Edit,
  Trash2,
  Save,
  RefreshCw,
  Eye,
  EyeOff,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Clock,
  Play,
  Pause,
  Square,
  Target,
  Layers,
  Network,
  Database,
  Settings,
  Search,
  Filter,
  Download,
  Upload,
  Share,
  Link,
  Maximize,
  Minimize,
  MoreHorizontal,
  MoreVertical,
  Info,
  HelpCircle,
  Calendar,
  User,
  Tag,
  Flag,
  Star,
  Bookmark,
  Copy,
  FileText,
  Code,
  Terminal,
  Activity,
  TrendingUp,
  TrendingDown,
  BarChart3,
  PieChart,
  LineChart
} from 'lucide-react';

// Hooks and Services
import { useOrchestration } from '../../hooks/useOrchestration';
import { useScanRules } from '../../hooks/useScanRules';
import { useValidation } from '../../hooks/useValidation';
import { orchestrationAPI } from '../../services/orchestration-apis';

// Types
import {
  DependencyGraph,
  DependencyNode,
  DependencyEdge,
  DependencyChain,
  DependencyConflict,
  DependencyResolution,
  ExecutionOrder,
  DependencyAnalysis,
  CircularDependency,
  DependencyMetrics,
  DependencyRule,
  DependencyConstraint,
  DependencyOptimization,
  DependencyValidation,
  DependencyConfiguration
} from '../../types/orchestration.types';

// Utils
import { dependencyAnalyzer } from '../../utils/workflow-engine';
import { graphLayoutAlgorithms } from '../../utils/optimization-algorithms';

interface DependencyResolverProps {
  workspaceId?: string;
  ruleSetId?: string;
  initialGraph?: DependencyGraph;
  autoResolve?: boolean;
  enableVisualization?: boolean;
  showMetrics?: boolean;
  onDependencyChange?: (graph: DependencyGraph) => void;
  onResolutionComplete?: (resolution: DependencyResolution) => void;
  onConflictDetected?: (conflicts: DependencyConflict[]) => void;
}

const DependencyResolver: React.FC<DependencyResolverProps> = ({
  workspaceId,
  ruleSetId,
  initialGraph,
  autoResolve = true,
  enableVisualization = true,
  showMetrics = true,
  onDependencyChange,
  onResolutionComplete,
  onConflictDetected
}) => {
  // Hooks
  const {
    workflows,
    resourcePools,
    dependencies,
    resolveDependencies,
    analyzeDependencyGraph,
    optimizeDependencyChain,
    validateDependencies,
    isLoading,
    error
  } = useOrchestration();

  const {
    scanRules,
    activeScanRules,
    createScanRule,
    updateScanRule
  } = useScanRules();

  const {
    validateSystem,
    validateConfiguration
  } = useValidation();

  // State Management
  const [dependencyGraph, setDependencyGraph] = useState<DependencyGraph>(
    initialGraph || {
      nodes: [],
      edges: [],
      metadata: {
        version: '1.0',
        lastModified: new Date().toISOString(),
        autoGenerated: false
      }
    }
  );
  const [selectedNode, setSelectedNode] = useState<DependencyNode | null>(null);
  const [selectedEdge, setSelectedEdge] = useState<DependencyEdge | null>(null);
  const [dependencyAnalysis, setDependencyAnalysis] = useState<DependencyAnalysis>({
    totalNodes: 0,
    totalEdges: 0,
    circularDependencies: [],
    criticalPath: [],
    maxDepth: 0,
    complexity: 'low',
    recommendations: []
  });
  const [resolutionResults, setResolutionResults] = useState<DependencyResolution[]>([]);
  const [conflicts, setConflicts] = useState<DependencyConflict[]>([]);
  const [executionOrder, setExecutionOrder] = useState<ExecutionOrder[]>([]);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [isResolving, setIsResolving] = useState(false);
  const [showVisualization, setShowVisualization] = useState(enableVisualization);
  const [visualizationLayout, setVisualizationLayout] = useState<'hierarchical' | 'force' | 'circular'>('hierarchical');
  const [filterOptions, setFilterOptions] = useState({
    nodeType: 'all',
    status: 'all',
    priority: 'all',
    complexity: 'all'
  });
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedTab, setSelectedTab] = useState('graph');
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [configuration, setConfiguration] = useState<DependencyConfiguration>({
    autoResolveConflicts: true,
    allowCircularDependencies: false,
    maxResolutionDepth: 10,
    optimizeExecutionOrder: true,
    enableParallelExecution: true,
    cacheResolutions: true
  });

  // Refs
  const visualizationRef = useRef<HTMLDivElement>(null);
  const analysisIntervalRef = useRef<NodeJS.Timeout>();

  // Initialize component
  useEffect(() => {
    if (autoResolve && dependencyGraph.nodes.length > 0) {
      handleAnalyzeDependencies();
    }
  }, [dependencyGraph, autoResolve]);

  // Periodic analysis update
  useEffect(() => {
    if (configuration.cacheResolutions) {
      analysisIntervalRef.current = setInterval(() => {
        if (dependencyGraph.nodes.length > 0) {
          handleAnalyzeDependencies();
        }
      }, 30000); // Update every 30 seconds

      return () => {
        if (analysisIntervalRef.current) {
          clearInterval(analysisIntervalRef.current);
        }
      };
    }
  }, [configuration.cacheResolutions, dependencyGraph]);

  // Analyze dependencies
  const handleAnalyzeDependencies = useCallback(async () => {
    if (isAnalyzing) return;

    setIsAnalyzing(true);
    try {
      const analysis = await dependencyAnalyzer.analyzeGraph(dependencyGraph);
      setDependencyAnalysis(analysis);

      // Check for conflicts
      const detectedConflicts = await dependencyAnalyzer.detectConflicts(dependencyGraph);
      setConflicts(detectedConflicts);

      if (detectedConflicts.length > 0 && onConflictDetected) {
        onConflictDetected(detectedConflicts);
      }

      // Generate execution order
      const order = await dependencyAnalyzer.generateExecutionOrder(dependencyGraph);
      setExecutionOrder(order);

    } catch (error) {
      console.error('Failed to analyze dependencies:', error);
    } finally {
      setIsAnalyzing(false);
    }
  }, [dependencyGraph, isAnalyzing, onConflictDetected]);

  // Resolve dependencies
  const handleResolveDependencies = useCallback(async () => {
    if (isResolving) return;

    setIsResolving(true);
    try {
      const resolutions = await resolveDependencies(dependencyGraph, configuration);
      setResolutionResults(resolutions);

      if (onResolutionComplete) {
        onResolutionComplete(resolutions[0]);
      }

      // Update graph with resolved dependencies
      if (resolutions.length > 0 && resolutions[0].resolvedGraph) {
        setDependencyGraph(resolutions[0].resolvedGraph);
        if (onDependencyChange) {
          onDependencyChange(resolutions[0].resolvedGraph);
        }
      }

    } catch (error) {
      console.error('Failed to resolve dependencies:', error);
    } finally {
      setIsResolving(false);
    }
  }, [dependencyGraph, configuration, isResolving, resolveDependencies, onResolutionComplete, onDependencyChange]);

  // Add new dependency
  const handleAddDependency = useCallback((source: string, target: string, type: string = 'requires') => {
    const newEdge: DependencyEdge = {
      id: `${source}-${target}-${Date.now()}`,
      source,
      target,
      type,
      strength: 1.0,
      isOptional: false,
      metadata: {
        createdAt: new Date().toISOString(),
        createdBy: 'user'
      }
    };

    setDependencyGraph(prev => ({
      ...prev,
      edges: [...prev.edges, newEdge],
      metadata: {
        ...prev.metadata,
        lastModified: new Date().toISOString()
      }
    }));
  }, []);

  // Remove dependency
  const handleRemoveDependency = useCallback((edgeId: string) => {
    setDependencyGraph(prev => ({
      ...prev,
      edges: prev.edges.filter(edge => edge.id !== edgeId),
      metadata: {
        ...prev.metadata,
        lastModified: new Date().toISOString()
      }
    }));
  }, []);

  // Add new node
  const handleAddNode = useCallback((node: Partial<DependencyNode>) => {
    const newNode: DependencyNode = {
      id: node.id || `node-${Date.now()}`,
      name: node.name || 'New Node',
      type: node.type || 'rule',
      status: 'active',
      priority: node.priority || 'medium',
      executionTime: node.executionTime || 0,
      resources: node.resources || { cpu: 1, memory: 512 },
      metadata: {
        createdAt: new Date().toISOString(),
        createdBy: 'user',
        ...node.metadata
      }
    };

    setDependencyGraph(prev => ({
      ...prev,
      nodes: [...prev.nodes, newNode],
      metadata: {
        ...prev.metadata,
        lastModified: new Date().toISOString()
      }
    }));
  }, []);

  // Remove node
  const handleRemoveNode = useCallback((nodeId: string) => {
    setDependencyGraph(prev => ({
      ...prev,
      nodes: prev.nodes.filter(node => node.id !== nodeId),
      edges: prev.edges.filter(edge => edge.source !== nodeId && edge.target !== nodeId),
      metadata: {
        ...prev.metadata,
        lastModified: new Date().toISOString()
      }
    }));
  }, []);

  // Optimize dependency chain
  const handleOptimizeDependencies = useCallback(async () => {
    try {
      const optimizedGraph = await optimizeDependencyChain(dependencyGraph);
      setDependencyGraph(optimizedGraph);
      
      if (onDependencyChange) {
        onDependencyChange(optimizedGraph);
      }

      await handleAnalyzeDependencies();
    } catch (error) {
      console.error('Failed to optimize dependencies:', error);
    }
  }, [dependencyGraph, optimizeDependencyChain, onDependencyChange, handleAnalyzeDependencies]);

  // Filter nodes and edges
  const filteredGraph = useMemo(() => {
    const filteredNodes = dependencyGraph.nodes.filter(node => {
      const matchesSearch = searchTerm === '' || 
        node.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        node.id.toLowerCase().includes(searchTerm.toLowerCase());

      const matchesType = filterOptions.nodeType === 'all' || node.type === filterOptions.nodeType;
      const matchesStatus = filterOptions.status === 'all' || node.status === filterOptions.status;
      const matchesPriority = filterOptions.priority === 'all' || node.priority === filterOptions.priority;

      return matchesSearch && matchesType && matchesStatus && matchesPriority;
    });

    const nodeIds = new Set(filteredNodes.map(n => n.id));
    const filteredEdges = dependencyGraph.edges.filter(edge => 
      nodeIds.has(edge.source) && nodeIds.has(edge.target)
    );

    return {
      ...dependencyGraph,
      nodes: filteredNodes,
      edges: filteredEdges
    };
  }, [dependencyGraph, searchTerm, filterOptions]);

  // Calculate metrics
  const metrics = useMemo(() => {
    const totalNodes = dependencyGraph.nodes.length;
    const totalEdges = dependencyGraph.edges.length;
    const avgDependencies = totalNodes > 0 ? totalEdges / totalNodes : 0;
    const maxDependencies = Math.max(
      ...dependencyGraph.nodes.map(node => 
        dependencyGraph.edges.filter(edge => edge.source === node.id).length
      ),
      0
    );

    return {
      totalNodes,
      totalEdges,
      avgDependencies,
      maxDependencies,
      circularDependencies: dependencyAnalysis.circularDependencies.length,
      complexity: dependencyAnalysis.complexity,
      criticalPathLength: dependencyAnalysis.criticalPath.length
    };
  }, [dependencyGraph, dependencyAnalysis]);

  // Render node badge
  const renderNodeBadge = (node: DependencyNode) => {
    const colorMap = {
      'rule': 'blue',
      'workflow': 'green',
      'resource': 'purple',
      'condition': 'yellow',
      'trigger': 'red'
    };

    return (
      <Badge variant={colorMap[node.type] as any} className="capitalize">
        {node.type}
      </Badge>
    );
  };

  // Render priority badge
  const renderPriorityBadge = (priority: string) => {
    const colorMap = {
      'low': 'secondary',
      'medium': 'default',
      'high': 'destructive',
      'critical': 'destructive'
    };

    return (
      <Badge variant={colorMap[priority] as any} className="capitalize">
        {priority}
      </Badge>
    );
  };

  // Render dependency visualization
  const renderDependencyVisualization = () => {
    if (!showVisualization) return null;

    return (
      <Card className="h-96">
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2">
              <Network className="w-5 h-5" />
              Dependency Graph
            </CardTitle>
            <div className="flex items-center gap-2">
              <Select value={visualizationLayout} onValueChange={setVisualizationLayout}>
                <SelectTrigger className="w-32">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="hierarchical">Hierarchical</SelectItem>
                  <SelectItem value="force">Force-directed</SelectItem>
                  <SelectItem value="circular">Circular</SelectItem>
                </SelectContent>
              </Select>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setShowVisualization(!showVisualization)}
              >
                {showVisualization ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div 
            ref={visualizationRef}
            className="w-full h-64 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300 flex items-center justify-center"
          >
            <div className="text-center text-gray-500">
              <Network className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p className="text-sm">Dependency Graph Visualization</p>
              <p className="text-xs mt-1">
                {metrics.totalNodes} nodes, {metrics.totalEdges} edges
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  // Render metrics dashboard
  const renderMetricsDashboard = () => (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-gray-600">Total Nodes</div>
              <div className="text-2xl font-bold mt-1">{metrics.totalNodes}</div>
            </div>
            <div className="p-3 bg-blue-50 rounded-full">
              <Target className="w-6 h-6 text-blue-600" />
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-gray-600">Dependencies</div>
              <div className="text-2xl font-bold mt-1">{metrics.totalEdges}</div>
            </div>
            <div className="p-3 bg-green-50 rounded-full">
              <GitBranch className="w-6 h-6 text-green-600" />
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-gray-600">Complexity</div>
              <div className="text-2xl font-bold mt-1 capitalize">{metrics.complexity}</div>
            </div>
            <div className="p-3 bg-purple-50 rounded-full">
              <BarChart3 className="w-6 h-6 text-purple-600" />
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-6">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-gray-600">Conflicts</div>
              <div className="text-2xl font-bold mt-1 text-red-600">{conflicts.length}</div>
            </div>
            <div className="p-3 bg-red-50 rounded-full">
              <AlertTriangle className="w-6 h-6 text-red-600" />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );

  return (
    <div className={`space-y-6 ${isFullscreen ? 'fixed inset-0 z-50 bg-white p-6 overflow-auto' : ''}`}>
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold flex items-center gap-2">
            <GitBranch className="w-6 h-6" />
            Dependency Resolver
          </h2>
          <p className="text-gray-600">Advanced dependency management and resolution system</p>
        </div>
        
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={handleAnalyzeDependencies}
            disabled={isAnalyzing}
          >
            {isAnalyzing ? <RefreshCw className="w-4 h-4 animate-spin" /> : <RefreshCw className="w-4 h-4" />}
            Analyze
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={handleResolveDependencies}
            disabled={isResolving}
          >
            {isResolving ? <Clock className="w-4 h-4 animate-spin" /> : <Play className="w-4 h-4" />}
            Resolve
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={handleOptimizeDependencies}
          >
            <Target className="w-4 h-4" />
            Optimize
          </Button>

          <Button
            variant="outline"
            size="sm"
            onClick={() => setIsFullscreen(!isFullscreen)}
          >
            {isFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />}
          </Button>
        </div>
      </div>

      {/* Metrics Dashboard */}
      {showMetrics && renderMetricsDashboard()}

      {/* Alerts for Conflicts */}
      {conflicts.length > 0 && (
        <Alert variant="destructive">
          <AlertTriangle className="w-4 h-4" />
          <AlertTitle>Dependency Conflicts Detected</AlertTitle>
          <AlertDescription>
            {conflicts.length} conflict(s) found in the dependency graph. Resolution is required before execution.
          </AlertDescription>
        </Alert>
      )}

      {/* Circular Dependencies Warning */}
      {dependencyAnalysis.circularDependencies.length > 0 && (
        <Alert variant="destructive">
          <XCircle className="w-4 h-4" />
          <AlertTitle>Circular Dependencies Detected</AlertTitle>
          <AlertDescription>
            {dependencyAnalysis.circularDependencies.length} circular dependency chain(s) detected. 
            These must be resolved to prevent infinite loops.
          </AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        <div className="lg:col-span-3">
          <Tabs value={selectedTab} onValueChange={setSelectedTab}>
            <TabsList className="grid w-full grid-cols-4">
              <TabsTrigger value="graph">Graph View</TabsTrigger>
              <TabsTrigger value="nodes">Nodes</TabsTrigger>
              <TabsTrigger value="dependencies">Dependencies</TabsTrigger>
              <TabsTrigger value="execution">Execution Order</TabsTrigger>
            </TabsList>

            <TabsContent value="graph" className="space-y-4">
              {renderDependencyVisualization()}

              {/* Critical Path */}
              {dependencyAnalysis.criticalPath.length > 0 && (
                <Card>
                  <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                      <ArrowRight className="w-5 h-5" />
                      Critical Path
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center gap-2 flex-wrap">
                      {dependencyAnalysis.criticalPath.map((nodeId, index) => {
                        const node = dependencyGraph.nodes.find(n => n.id === nodeId);
                        return (
                          <React.Fragment key={nodeId}>
                            {index > 0 && <ArrowRight className="w-4 h-4 text-gray-400" />}
                            <Badge variant="outline" className="px-3 py-1">
                              {node?.name || nodeId}
                            </Badge>
                          </React.Fragment>
                        );
                      })}
                    </div>
                    <div className="mt-3 text-sm text-gray-600">
                      Total execution time: {dependencyAnalysis.criticalPath.reduce((total, nodeId) => {
                        const node = dependencyGraph.nodes.find(n => n.id === nodeId);
                        return total + (node?.executionTime || 0);
                      }, 0).toFixed(2)}s
                    </div>
                  </CardContent>
                </Card>
              )}
            </TabsContent>

            <TabsContent value="nodes" className="space-y-4">
              {/* Filters */}
              <Card>
                <CardContent className="p-4">
                  <div className="flex flex-wrap items-center gap-4">
                    <div className="flex items-center gap-2">
                      <Search className="w-4 h-4" />
                      <Input
                        placeholder="Search nodes..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        className="w-64"
                      />
                    </div>
                    
                    <Select value={filterOptions.nodeType} onValueChange={(value) =>
                      setFilterOptions(prev => ({ ...prev, nodeType: value }))
                    }>
                      <SelectTrigger className="w-32">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="all">All Types</SelectItem>
                        <SelectItem value="rule">Rules</SelectItem>
                        <SelectItem value="workflow">Workflows</SelectItem>
                        <SelectItem value="resource">Resources</SelectItem>
                        <SelectItem value="condition">Conditions</SelectItem>
                      </SelectContent>
                    </Select>

                    <Select value={filterOptions.status} onValueChange={(value) =>
                      setFilterOptions(prev => ({ ...prev, status: value }))
                    }>
                      <SelectTrigger className="w-32">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="all">All Status</SelectItem>
                        <SelectItem value="active">Active</SelectItem>
                        <SelectItem value="inactive">Inactive</SelectItem>
                        <SelectItem value="pending">Pending</SelectItem>
                      </SelectContent>
                    </Select>

                    <Button 
                      size="sm" 
                      onClick={() => {
                        const newNode = {
                          name: `Node ${dependencyGraph.nodes.length + 1}`,
                          type: 'rule' as const,
                          priority: 'medium' as const
                        };
                        handleAddNode(newNode);
                      }}
                    >
                      <Plus className="w-4 h-4 mr-2" />
                      Add Node
                    </Button>
                  </div>
                </CardContent>
              </Card>

              {/* Nodes Table */}
              <Card>
                <CardContent className="p-0">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Name</TableHead>
                        <TableHead>Type</TableHead>
                        <TableHead>Status</TableHead>
                        <TableHead>Priority</TableHead>
                        <TableHead>Execution Time</TableHead>
                        <TableHead>Dependencies</TableHead>
                        <TableHead>Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredGraph.nodes.map((node) => {
                        const incomingDeps = filteredGraph.edges.filter(e => e.target === node.id).length;
                        const outgoingDeps = filteredGraph.edges.filter(e => e.source === node.id).length;
                        
                        return (
                          <TableRow 
                            key={node.id}
                            className="cursor-pointer hover:bg-gray-50"
                            onClick={() => setSelectedNode(node)}
                          >
                            <TableCell className="font-medium">{node.name}</TableCell>
                            <TableCell>{renderNodeBadge(node)}</TableCell>
                            <TableCell>
                              <Badge variant={node.status === 'active' ? 'success' : 'secondary'}>
                                {node.status}
                              </Badge>
                            </TableCell>
                            <TableCell>{renderPriorityBadge(node.priority)}</TableCell>
                            <TableCell>{node.executionTime.toFixed(2)}s</TableCell>
                            <TableCell>
                              <div className="flex items-center gap-2 text-sm">
                                <span>In: {incomingDeps}</span>
                                <span>Out: {outgoingDeps}</span>
                              </div>
                            </TableCell>
                            <TableCell>
                              <div className="flex items-center gap-1">
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setSelectedNode(node);
                                  }}
                                >
                                  <Edit className="w-3 h-3" />
                                </Button>
                                <Button
                                  variant="ghost"
                                  size="sm"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleRemoveNode(node.id);
                                  }}
                                >
                                  <Trash2 className="w-3 h-3" />
                                </Button>
                              </div>
                            </TableCell>
                          </TableRow>
                        );
                      })}
                    </TableBody>
                  </Table>
                </CardContent>
              </Card>
            </TabsContent>

            <TabsContent value="dependencies" className="space-y-4">
              <Card>
                <CardHeader>
                  <div className="flex items-center justify-between">
                    <CardTitle>Dependency Relationships</CardTitle>
                    <Button 
                      size="sm"
                      onClick={() => {
                        // Add dependency dialog would open here
                      }}
                    >
                      <Plus className="w-4 h-4 mr-2" />
                      Add Dependency
                    </Button>
                  </div>
                </CardHeader>
                <CardContent className="p-0">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Source</TableHead>
                        <TableHead>Target</TableHead>
                        <TableHead>Type</TableHead>
                        <TableHead>Strength</TableHead>
                        <TableHead>Optional</TableHead>
                        <TableHead>Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredGraph.edges.map((edge) => {
                        const sourceNode = dependencyGraph.nodes.find(n => n.id === edge.source);
                        const targetNode = dependencyGraph.nodes.find(n => n.id === edge.target);
                        
                        return (
                          <TableRow key={edge.id}>
                            <TableCell>{sourceNode?.name || edge.source}</TableCell>
                            <TableCell>{targetNode?.name || edge.target}</TableCell>
                            <TableCell>
                              <Badge variant="outline" className="capitalize">
                                {edge.type}
                              </Badge>
                            </TableCell>
                            <TableCell>
                              <Progress value={edge.strength * 100} className="w-16" />
                            </TableCell>
                            <TableCell>
                              {edge.isOptional ? (
                                <CheckCircle className="w-4 h-4 text-green-600" />
                              ) : (
                                <XCircle className="w-4 h-4 text-red-600" />
                              )}
                            </TableCell>
                            <TableCell>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handleRemoveDependency(edge.id)}
                              >
                                <Trash2 className="w-3 h-3" />
                              </Button>
                            </TableCell>
                          </TableRow>
                        );
                      })}
                    </TableBody>
                  </Table>
                </CardContent>
              </Card>
            </TabsContent>

            <TabsContent value="execution" className="space-y-4">
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Play className="w-5 h-5" />
                    Execution Order
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  {executionOrder.length === 0 ? (
                    <div className="text-center py-8 text-gray-500">
                      <Play className="w-8 h-8 mx-auto mb-2 opacity-50" />
                      <p>No execution order available</p>
                      <p className="text-sm mt-1">Run dependency analysis to generate execution order</p>
                    </div>
                  ) : (
                    <div className="space-y-4">
                      {executionOrder.map((step, index) => (
                        <div key={index} className="flex items-center gap-4 p-4 bg-gray-50 rounded-lg">
                          <div className="flex items-center justify-center w-8 h-8 bg-blue-100 text-blue-600 rounded-full font-medium">
                            {index + 1}
                          </div>
                          <div className="flex-1">
                            <div className="font-medium">{step.name}</div>
                            <div className="text-sm text-gray-600">{step.description}</div>
                          </div>
                          <div className="text-right">
                            <div className="text-sm text-gray-600">Est. Time</div>
                            <div className="font-medium">{step.estimatedTime.toFixed(2)}s</div>
                          </div>
                          <div className="text-right">
                            <div className="text-sm text-gray-600">Parallel Tasks</div>
                            <div className="font-medium">{step.parallelTasks}</div>
                          </div>
                        </div>
                      ))}
                      
                      <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                        <div className="flex items-center justify-between">
                          <span className="font-medium">Total Execution Time:</span>
                          <span className="font-bold text-blue-600">
                            {executionOrder.reduce((total, step) => total + step.estimatedTime, 0).toFixed(2)}s
                          </span>
                        </div>
                        <div className="flex items-center justify-between mt-2">
                          <span className="font-medium">Parallelizable Steps:</span>
                          <span className="font-bold text-green-600">
                            {executionOrder.filter(step => step.parallelTasks > 1).length}
                          </span>
                        </div>
                      </div>
                    </div>
                  )}
                </CardContent>
              </Card>
            </TabsContent>
          </Tabs>
        </div>

        <div className="space-y-6">
          {/* Analysis Results */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <BarChart3 className="w-5 h-5" />
                Analysis Results
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label>Graph Complexity</Label>
                <div className="mt-1">
                  <Badge variant={
                    dependencyAnalysis.complexity === 'low' ? 'success' :
                    dependencyAnalysis.complexity === 'medium' ? 'default' :
                    'destructive'
                  }>
                    {dependencyAnalysis.complexity}
                  </Badge>
                </div>
              </div>
              
              <div>
                <Label>Max Depth</Label>
                <div className="mt-1 font-mono text-lg">{dependencyAnalysis.maxDepth}</div>
              </div>
              
              <div>
                <Label>Circular Dependencies</Label>
                <div className="mt-1">
                  <Badge variant={dependencyAnalysis.circularDependencies.length > 0 ? 'destructive' : 'success'}>
                    {dependencyAnalysis.circularDependencies.length}
                  </Badge>
                </div>
              </div>

              {dependencyAnalysis.recommendations.length > 0 && (
                <div>
                  <Label>Recommendations</Label>
                  <div className="mt-2 space-y-2">
                    {dependencyAnalysis.recommendations.map((rec, index) => (
                      <Alert key={index} variant="default">
                        <Info className="w-4 h-4" />
                        <AlertDescription className="text-xs">
                          {rec}
                        </AlertDescription>
                      </Alert>
                    ))}
                  </div>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Configuration */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Settings className="w-5 h-5" />
                Configuration
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-center justify-between">
                <Label htmlFor="auto-resolve">Auto Resolve Conflicts</Label>
                <Switch
                  id="auto-resolve"
                  checked={configuration.autoResolveConflicts}
                  onCheckedChange={(checked) =>
                    setConfiguration(prev => ({ ...prev, autoResolveConflicts: checked }))
                  }
                />
              </div>
              
              <div className="flex items-center justify-between">
                <Label htmlFor="allow-circular">Allow Circular Dependencies</Label>
                <Switch
                  id="allow-circular"
                  checked={configuration.allowCircularDependencies}
                  onCheckedChange={(checked) =>
                    setConfiguration(prev => ({ ...prev, allowCircularDependencies: checked }))
                  }
                />
              </div>
              
              <div className="flex items-center justify-between">
                <Label htmlFor="optimize-order">Optimize Execution Order</Label>
                <Switch
                  id="optimize-order"
                  checked={configuration.optimizeExecutionOrder}
                  onCheckedChange={(checked) =>
                    setConfiguration(prev => ({ ...prev, optimizeExecutionOrder: checked }))
                  }
                />
              </div>
              
              <div className="flex items-center justify-between">
                <Label htmlFor="parallel-execution">Enable Parallel Execution</Label>
                <Switch
                  id="parallel-execution"
                  checked={configuration.enableParallelExecution}
                  onCheckedChange={(checked) =>
                    setConfiguration(prev => ({ ...prev, enableParallelExecution: checked }))
                  }
                />
              </div>

              <div>
                <Label htmlFor="max-depth">Max Resolution Depth</Label>
                <Select
                  value={configuration.maxResolutionDepth.toString()}
                  onValueChange={(value) =>
                    setConfiguration(prev => ({ ...prev, maxResolutionDepth: parseInt(value) }))
                  }
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="5">5 levels</SelectItem>
                    <SelectItem value="10">10 levels</SelectItem>
                    <SelectItem value="15">15 levels</SelectItem>
                    <SelectItem value="20">20 levels</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle>Quick Actions</CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Button className="w-full justify-start" variant="outline">
                <Download className="w-4 h-4 mr-2" />
                Export Graph
              </Button>
              <Button className="w-full justify-start" variant="outline">
                <Upload className="w-4 h-4 mr-2" />
                Import Graph
              </Button>
              <Button className="w-full justify-start" variant="outline">
                <Copy className="w-4 h-4 mr-2" />
                Clone Graph
              </Button>
              <Button className="w-full justify-start" variant="outline">
                <FileText className="w-4 h-4 mr-2" />
                Generate Report
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Node Details Modal */}
      {selectedNode && (
        <Dialog open={!!selectedNode} onOpenChange={() => setSelectedNode(null)}>
          <DialogContent className="max-w-2xl">
            <DialogHeader>
              <DialogTitle className="flex items-center gap-2">
                <Target className="w-5 h-5" />
                Node Details: {selectedNode.name}
              </DialogTitle>
              <DialogDescription>
                Configure and manage node properties and relationships
              </DialogDescription>
            </DialogHeader>
            
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label>Node ID</Label>
                  <Input value={selectedNode.id} disabled />
                </div>
                <div>
                  <Label>Type</Label>
                  <div className="mt-1">
                    {renderNodeBadge(selectedNode)}
                  </div>
                </div>
                <div>
                  <Label>Status</Label>
                  <div className="mt-1">
                    <Badge variant={selectedNode.status === 'active' ? 'success' : 'secondary'}>
                      {selectedNode.status}
                    </Badge>
                  </div>
                </div>
                <div>
                  <Label>Priority</Label>
                  <div className="mt-1">
                    {renderPriorityBadge(selectedNode.priority)}
                  </div>
                </div>
              </div>

              <div>
                <Label>Name</Label>
                <Input 
                  value={selectedNode.name}
                  onChange={(e) => {
                    const updatedNode = { ...selectedNode, name: e.target.value };
                    setSelectedNode(updatedNode);
                    // Update in graph
                    setDependencyGraph(prev => ({
                      ...prev,
                      nodes: prev.nodes.map(n => n.id === selectedNode.id ? updatedNode : n)
                    }));
                  }}
                />
              </div>

              <div>
                <Label>Execution Time (seconds)</Label>
                <Input 
                  type="number"
                  value={selectedNode.executionTime}
                  onChange={(e) => {
                    const updatedNode = { ...selectedNode, executionTime: parseFloat(e.target.value) || 0 };
                    setSelectedNode(updatedNode);
                    setDependencyGraph(prev => ({
                      ...prev,
                      nodes: prev.nodes.map(n => n.id === selectedNode.id ? updatedNode : n)
                    }));
                  }}
                />
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label>CPU Requirements</Label>
                  <Input 
                    type="number"
                    value={selectedNode.resources.cpu}
                    onChange={(e) => {
                      const updatedNode = { 
                        ...selectedNode, 
                        resources: { 
                          ...selectedNode.resources, 
                          cpu: parseInt(e.target.value) || 1 
                        }
                      };
                      setSelectedNode(updatedNode);
                      setDependencyGraph(prev => ({
                        ...prev,
                        nodes: prev.nodes.map(n => n.id === selectedNode.id ? updatedNode : n)
                      }));
                    }}
                  />
                </div>
                <div>
                  <Label>Memory Requirements (MB)</Label>
                  <Input 
                    type="number"
                    value={selectedNode.resources.memory}
                    onChange={(e) => {
                      const updatedNode = { 
                        ...selectedNode, 
                        resources: { 
                          ...selectedNode.resources, 
                          memory: parseInt(e.target.value) || 512 
                        }
                      };
                      setSelectedNode(updatedNode);
                      setDependencyGraph(prev => ({
                        ...prev,
                        nodes: prev.nodes.map(n => n.id === selectedNode.id ? updatedNode : n)
                      }));
                    }}
                  />
                </div>
              </div>

              <div className="flex justify-end gap-2">
                <Button variant="outline" onClick={() => setSelectedNode(null)}>
                  Cancel
                </Button>
                <Button onClick={() => setSelectedNode(null)}>
                  <Save className="w-4 h-4 mr-2" />
                  Save Changes
                </Button>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
};

export default DependencyResolver;